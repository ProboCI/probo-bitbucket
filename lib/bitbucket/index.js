'use strict';

var util = require('util');
var request = require('request');

/**
 * @param {Object} config - An object with the following properties:
 * @param {Logger} config.log - logger to use
 * @param {string} config.version - '2.0' - the Bitbucket API version to use. Defaults to '2.0'
 * @param {Object} config.auth - An authorization object:
 * @param {string} config.auth.consumerKey - consumer key for the API (get from BitBucket integration dashboard)
 * @param {string} config.auth.consumerSecret - consumer secret for the API (get from BitBucket integration dashboard)
 * @param {string} config.auth.token - token that was generated by BitBucket for the user (almost certainly this needs to be refreshed, they only last 1 hour for bitbucket.
 * @param {string} config.auth.refreshToken - refresh token that was generated by BitBucket for the user
 */
function Bitbucket(config) {
  this.config = config || {};
  this.log = config.log.child({consumerKey: config.auth.consumerKey});

  this.authenticate(config.auth);

  // bind all methods to this so context of this.repos.method is still this.
  var subs = ['repos', 'statuses'];
  var method;

  for (let sub of subs) {
    // make sure we don't bind the prototype function to this!
    let newSub = {};

    for (let m in this[sub]) {
      if (this[sub].hasOwnProperty(m)) {
        method = this[sub][m];
        if (typeof method.bind == 'function') {
          newSub[m] = method.bind(this);
        }
      }
    }

    this[sub] = newSub;
  }
}

Bitbucket.prototype.utils = {
  extend: function(dest, src) {
    dest = dest || {};
    src = src || {};

    var ret = {};
    var x;

    for (x in dest) {
      if (dest.hasOwnProperty(x)) {
        ret[x] = dest[x];
      }
    }

    for (x in src) {
      if (src.hasOwnProperty(x)) {
        ret[x] = src[x];
      }
    }

    return ret;
  },

  defaults: function(dest, src) {
    dest = dest || {};
    src = src || {};

    var ret = {};
    var x;

    for (x in dest) {
      if (dest.hasOwnProperty(x)) {
        ret[x] = dest[x];
      }
    }

    for (x in src) {
      if (typeof dest[x] == 'undefined') {
        ret[x] = src[x];
      }
    }

    return ret;
  },
};

/**
 * Synchronous call that sets up the HTTP client with the proper auth
 */

Bitbucket.prototype.authenticate = function(auth) {
  if (!auth) {
    throw new Error('Bitbucket authentication config missing');
  }

  this.auth = this.utils.defaults(auth, this.auth);

  this.oauth = {
    headers: this.makeAuthHeaders(this.auth.token),
  };
};

/**
 * @param {Object} opts : all standard request call options with the addition of the following (that don't get passed to
 * request):
 * @param {string} opts.method - lowercases HTTP method, with "del" instead of "DELETE" (defaults to "get")
 * @param {string} opts.path (appended to this.url)
 * @param {function} cb - The function to run once the token is refreshed.
 */
Bitbucket.prototype.http = function(opts, cb) {
  var self = this;

  // always grab a new token
  this.refreshToken.bind(this)(function(err, auth) {
    if (err) { return cb(err); }

    return self._http(opts, cb);
  });
};

Bitbucket.prototype._http = function(opts, cb) {
  opts = opts || {};
  var method = opts.method || 'get';
  var version = opts.version || '2.0';
  var url = `https://api.bitbucket.org/${version}`;

  opts = this.utils.defaults(opts, {
    uri: opts.url || (url + opts.path),
    headers: this.utils.defaults(this.oauth.headers, opts.headers),
    json: true,
  });

  delete opts.version;
  delete opts.url;
  delete opts.method;
  delete opts.path;

  function handler(err, res, body) {
    if (err) return cb(err);

    if (!(res.statusCode >= 200 && res.statusCode < 300)) {
      err = new Error(JSON.stringify(body));
      err.statusCode = res.statusCode;
      err.statusMessage = res.statusMessage;

      return cb(err);
    }

    cb(err, res, body);
  }

  return request[method](opts, handler);
};

Bitbucket.prototype.refreshToken = function(done) {
  var self = this;
  this.log.info('refreshing token');

  var opts = {
    uri: 'https://bitbucket.org/site/oauth2/access_token',
    form: {
      grant_type: 'refresh_token',
      refresh_token: this.auth.refreshToken,
    },
    auth: {
      user: this.auth.consumerKey,
      pass: this.auth.consumerSecret,
    },
    json: true,
  };

  request.post(opts, function(error, response, body) {
    if (error) {
      return done(error);
    }

    self.log.info({auth: body.access_token}, 'refreshed auth token from BB');

    // we have new auth credentials, so update auth with them
    self.authenticate({token: body.access_token});
    done(null, body);
  });
};

Bitbucket.prototype.isTokenError = function(body) {
  return (body &&
          body.error &&
          body.error.message === 'Access token expired. Use your refresh token to obtain a new access token.');
};

Bitbucket.prototype.makeAuthHeaders = function(token) {
  return {
    authorization: `Bearer ${token}`,
  };
};

Bitbucket.prototype.repos = {

  /**
   * Gets content of files (path specified) or directories (no path)
   * @param {object} opts
   * @param {object} opts.accountName - required account name (ex: zanchin)
   * @param {object} opts.repositorySlug - required account name (ex: myrepo)
   * @param {object} opts.ref - commit sha
   * @param {object} [opts.at] - commit sha (alias), if not specified, opts.ref will be used
   * @param {object} [opts.path] - path of the file to get within the repo. if empty or not specified, returns directory listing at root
   */
  getContent: function(opts, cb) {
    if (typeof opts == 'function') {
      cb = opts;
      opts = {};
    }

    if (!opts.accountName) {
      return cb(new Error('getContent accountName required'));
    }
    if (!opts.repositorySlug) {
      return cb(new Error('getContent repositorySlug required'));
    }

    opts.path = opts.path || '';
    opts.ref = opts.at || opts.ref;
    var path = `/repositories/${opts.accountName}/${opts.repositorySlug}/src/${opts.ref}/${opts.path}`;

    delete opts.path;
    delete opts.at;
    delete opts.ref;

    var params = {
      version: '1.0',
      path,
    };

    return this.http(params, function(err, res, content) {
      if (err) return cb(err);

      if (content.data) {
        // getting contents of a file
        content = content.data;
      }
      else if (content.path) {
        content = content.files;
      }

      cb(err, content);
    });
  },
};

Bitbucket.prototype.statuses = {
  create: function(status, opts, cb) {
    if (typeof opts == 'function') {
      cb = opts;
      opts = {};
    }

    // validate status
    if (!status) {
      return cb(new Error('statuses.create status required'));
    }

    var requiredStatusFields = ['state', 'key', 'url'];
    for (let field of requiredStatusFields) {
      if (!status[field]) {
        return cb(new Error('statuses.create status.' + field + ' required'));
      }
    }

    // automatically uppcase state
    status.state = status.state.toUpperCase();
    var validStates = ['SUCCESSFUL', 'FAILED', 'INPROGRESS'];
    if (validStates.indexOf(status.state) < 0) {
      return cb(new Error('statuses.create status.state required to be one of ' + ['SUCCESSFUL', 'FAILED', 'INPROGRESS'].join(', ')));
    }

    // validate opts
    if (!opts.commitId && !opts.ref) {
      return cb(new Error('statuses.create commitId or ref config required'));
    }

    var ref = opts.commitId || opts.ref;
    var path = util.format('/repositories/%s/commit/%s/statuses/build',
                           opts.slug, ref);

    delete opts.commitId;
    delete opts.ref;
    delete opts.slug;

    var params = this.utils.defaults(opts, {
      path: path,
      method: 'post',
      body: status,
      json: true,
    });

    this.http(params, function(err, res, content) {
      if (err) return cb(err);

      if (content && content.errors) {
        return cb(new Error(content.errors[0].message));
      }

      cb(err, content);
    });
  },
};


module.exports = Bitbucket;
