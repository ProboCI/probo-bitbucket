'use strict';

const util = require('util');
const request = require('request');

/**
 * Handles HTTP requests to Bitbucket API
 */
class BitbucketApi {

  /**
   * @param {Object} config - An object with the following properties:
   * @param {Logger} config.log - logger to use
   * @param {string} config.version - '2.0' - the Bitbucket API version to use. Defaults to '2.0'
   * @param {Object} config.auth - An authorization object:
   * @param {string} config.auth.consumerKey - consumer key for the API (get from BitBucket integration dashboard)
   * @param {string} config.auth.consumerSecret - consumer secret for the API (get from BitBucket integration dashboard)
   * @param {string} config.auth.token - token that was generated by BitBucket for the user (almost certainly this needs to be refreshed, they only last 1 hour for bitbucket.
   * @param {string} config.auth.refreshToken - refresh token that was generated by BitBucket for the user
   */
  constructor(config) {
    this.config = config || {};
    this.log = config.log.child({consumerKey: config.auth.consumerKey});

    this.authenticate(config.auth);

    // bind all methods to this so context of this.repos.method is still this.
    let subs = ['repos', 'statuses'];
    let method;

    for (let sub of subs) {
      // make sure we don't bind the prototype function to this!
      let newSub = {};

      for (let m in this[sub]) {
        if (this[sub].hasOwnProperty(m)) {
          method = this[sub][m];
          if (typeof method.bind == 'function') {
            newSub[m] = method.bind(this);
          }
        }
      }

      this[sub] = newSub;
    }
  }

  /**
   * Synchronous call that sets up the HTTP client with the proper auth tokens.
   *
   * @param {Object} auth - An object containing parameters to be sotred in this.auth.
   * @param {String} auth.token - The auth token to include in the headers of new requests.
   */
  authenticate(auth) {
    if (!auth) {
      throw new Error('Bitbucket authentication config missing');
    }

    this.auth = this.utils.defaults(auth, this.auth);

    this.oauth = {
      headers: this.makeAuthHeaders(this.auth.token),
    };
  }

  /**
   * @param {Object} opts : all standard request call options with the addition of the following (that don't get passed to
   * request):
   * @param {string} opts.method - lowercases HTTP method, with "del" instead of "DELETE" (defaults to "get")
   * @param {string} opts.path (appended to this.url)
   * @param {function} cb - The function to run once the token is refreshed and full http request is complete.
   */
  http(opts, cb) {
    // Always grab a new token
    this.refreshToken.bind(this)((err, auth) => {
      if (err) { return cb(err); }

      return this._http(opts, cb);
    });
  }

  /**
   * @param {Object} opts : all standard request call options with the addition of the following (that don't get passed to request).
   * @param {string} opts.method - lowercases HTTP method, with "del" instead of "DELETE" (defaults to "get")
   * @param {string} opts.path (appended to this.url)
   * @param {function} cb - The function to run once the http request is complete.
   * @return {Mixed} - The result of the request call.
   */
  _http(opts, cb) {
    opts = opts || {};
    let method = opts.method || 'get';
    let version = opts.version || '2.0';
    let url = `https://api.bitbucket.org/${version}`;

    opts = this.utils.defaults(opts, {
      uri: opts.url || (url + opts.path),
      headers: this.utils.defaults(this.oauth.headers, opts.headers),
      json: true,
    });

    delete opts.version;
    delete opts.url;
    delete opts.method;
    delete opts.path;

    function handler(err, res, body) {
      if (err) return cb(err);

      if (!(res.statusCode >= 200 && res.statusCode < 300)) {
        err = new Error(JSON.stringify(body));
        err.statusCode = res.statusCode;
        err.statusMessage = res.statusMessage;

        return cb(err);
      }

      cb(err, res, body);
    }

    return request[method](opts, handler);
  }

  refreshToken(done) {
    this.log.info('refreshing token');

    let opts = {
      uri: 'https://bitbucket.org/site/oauth2/access_token',
      form: {
        grant_type: 'refresh_token',
        refresh_token: this.auth.refreshToken,
      },
      auth: {
        user: this.auth.consumerKey,
        pass: this.auth.consumerSecret,
      },
      json: true,
    };

    request.post(opts, (error, response, body) => {
      if (error) {
        return done(error);
      }

      this.log.debug('refreshed auth token from BB');

      // we have new auth credentials, so update auth with them
      this.authenticate({token: body.access_token});
      done(null, body);
    });
  }

  isTokenError(body) {
    return (body &&
            body.error &&
            body.error.message === 'Access token expired. Use your refresh token to obtain a new access token.');
  }

  makeAuthHeaders(token) {
    return {
      authorization: `Bearer ${token}`,
    };
  }
}

BitbucketApi.prototype.repos = {

  /**
   * Gets information on a commit.
   */
  getCommit: function(opts, cb) {
    let required = [
      'owner',
      'repo',
      'ref',
    ];
    for (let field of required) {
      if (!opts.hasOwnProperty(field)) {
        return cb(new Error(`${field} is required when calling getPullRequest`));
      }
    }

    let params = {
      method: 'get',
      path: `/repositories/${opts.owner}/${opts.repo}/commit/${opts.ref}`
    };

    this.log.debug({params}, `Getting commit ${opts.owner}/${opts.repo} #${opts.ref}`);

    this.http(params, function(err, res, body) {
      if (err) return cb(err);

      cb(null, body);
    });
  },

  /**
   * Gets the status of a bitbucket pull request.
   */
  getPullRequest: function(opts, cb) {
    if (typeof opts == 'function') {
      cb = opts;
      opts = {};
    }
    let required = [
      'owner',
      'repo',
      'id',
    ];
    for (let field of required) {
      if (!opts.hasOwnProperty(field)) {
        return cb(new Error(`${field} is required when calling getPullRequest`));
      }
    }
    let params = {
      method: 'get',
      path: `/repositories/${opts.owner}/${opts.repo}/pullrequests/${opts.id}`,
    };
    this.log.debug({params}, `Getting PR ${opts.owner}/${opts.repo} #${opts.id}`);

    this.http(params, function(err, res, body) {
      if (err) return cb(err);

      cb(err, body);
    });
  },

  /**
   * Gets content of files (path specified) or directories (no path)
   *
   * @param {Object} opts - A hash containing configuration options.
   * @param {String} opts.accountName - The name of the account to retrieve data for.
   * @param {String} opts.repositorySlug - The name of the repository.
   * @param {String} opts.path - The path of the file to retrieve.
   * @param {object} [opts.at] - commit sha (alias), if not specified, opts.ref will be used
   * @param {object} [opts.path] - path of the file to get within the repo. if empty or not specified, returns directory listing at root.
   * @param {Function} cb - The calback function to call when the content has been retrieved.
   * @return {Null} - No return value.
   */
  getContent: function(opts, cb) {
    if (typeof opts == 'function') {
      cb = opts;
      opts = {};
    }

    if (!opts.accountName) {
      return cb(new Error('getContent accountName required'));
    }
    if (!opts.repositorySlug) {
      return cb(new Error('getContent repositorySlug required'));
    }

    opts.path = opts.path || '';
    opts.ref = opts.at || opts.ref;
    var path = `/repositories/${opts.accountName}/${opts.repositorySlug}/src/${opts.ref}/${opts.path}?pagelen=100`;

    delete opts.path;
    delete opts.at;
    delete opts.ref;

    var params = {
      path,
    };

    this.http(params, function(err, res, content) {
      if (err) return cb(err);

      if (content.data) {
        // getting contents of a file
        content = content.data;
      }
      else if (content.path) {
        content = content.files;
      }
      else if (content.values) {
        content = content.values;
      }
      cb(err, content);
    });
  },
};

BitbucketApi.prototype.statuses = {
  create: function(status, opts, cb) {
    if (typeof opts == 'function') {
      cb = opts;
      opts = {};
    }

    // validate status
    if (!status) {
      return cb(new Error('statuses.create status required'));
    }

    let requiredStatusFields = ['state', 'key', 'url'];
    let field;
    for (field of requiredStatusFields) {
      if (!status[field]) {
        return cb(new Error(`statuses.create status.${field} required`));
      }
    }

    // automatically uppcase state
    status.state = status.state.toUpperCase();
    let validStates = ['SUCCESSFUL', 'FAILED', 'INPROGRESS'];
    if (validStates.indexOf(status.state) < 0) {
      return cb(new Error(`statuses.create status. ${field} required to be one of ` + ['SUCCESSFUL', 'FAILED', 'INPROGRESS'].join(', ')));
    }

    // validate opts
    if (!opts.commitId && !opts.ref) {
      return cb(new Error('statuses.create commitId or ref config required'));
    }

    let ref = opts.commitId || opts.ref;
    let path = util.format('/repositories/%s/commit/%s/statuses/build',
                           opts.slug, ref);

    delete opts.commitId;
    delete opts.ref;
    delete opts.slug;

    let params = this.utils.defaults(opts, {
      path: path,
      method: 'post',
      body: status,
      json: true,
    });

    this.http(params, function(err, res, content) {
      if (err) return cb(err);

      if (content && content.errors) {
        return cb(new Error(content.errors[0].message));
      }
      cb(err, content);
    });
  },
};

BitbucketApi.prototype.utils = {
  extend: function(dest, src) {
    dest = dest || {};
    src = src || {};

    let ret = {};

    for (let x in dest) {
      if (dest.hasOwnProperty(x)) {
        ret[x] = dest[x];
      }
    }

    for (let x in src) {
      if (src.hasOwnProperty(x)) {
        ret[x] = src[x];
      }
    }

    return ret;
  },

  defaults: function(dest, src) {
    dest = dest || {};
    src = src || {};

    let ret = {};

    for (let x in dest) {
      if (dest.hasOwnProperty(x)) {
        ret[x] = dest[x];
      }
    }

    for (let x in src) {
      if (src.hasOwnProperty(x) && typeof dest[x] == 'undefined') {
        ret[x] = src[x];
      }
    }

    return ret;
  },
};

module.exports = BitbucketApi;
